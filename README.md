{
  "readme": "# ftt_mix: Cross-Chain Bridge Event Listener Simulation\n\nThis repository contains a Python-based simulation of a cross-chain bridge event listener. It is designed as an architectural showcase, demonstrating how a critical off-chain component of a decentralized system can be structured. The script listens for `DepositInitiated` events on a source blockchain, processes them, and then simulates the creation and signing of a corresponding `claimWithdrawal` transaction on a destination blockchain.\n\nThis is not a production-ready relayer but a comprehensive model intended for educational and architectural review purposes.\n\n## Concept\n\nCross-chain bridges are essential for blockchain interoperability, allowing users to move assets from one chain to another. A common architecture involves:\n\n1.  **Source Chain**: A user deposits assets into a bridge smart contract, which locks the assets and emits an event (e.g., `DepositInitiated`).\n2.  **Off-Chain Relayer/Listener**: A trusted service (or a network of services) constantly monitors the source chain for these deposit events.\n3.  **Destination Chain**: Upon detecting a valid event, the relayer submits a transaction to a bridge contract on the destination chain to mint a corresponding amount of wrapped assets for the user.\n\nThis project simulates the **Off-Chain Relayer/Listener** component. It connects to two blockchain RPC endpoints, scans for events, and prepares transactions for the destination chain.\n\n## Code Architecture\n\nThe script is designed with a clear separation of concerns, using multiple classes to handle distinct responsibilities.\n\n```\n+-------------------+      +-----------------------+\n|   ConfigLoader    |----->|     BridgeListener    |<---- (Orchestrator)\n+-------------------+      | (Main Application)    |\n                           +-----------+-----------+\n                                       |\n                  +--------------------+--------------------+\n                  |                                         |\n                  v                                         v\n+------------------------+                     +----------------------+\n|     EventScanner       |                     |  TransactionRelayer  |\n+------------------------+                     +----------------------+\n| - Scans for events on  |                     | - Simulates tx on    |\n|   the source chain     |                     |   destination chain  |\n| - Manages scan state   |                     | - Signs transaction  |\n+-----------+------------+                     +----------+-----------+\n            |                                              |\n            v                                              v\n+------------------------+                     +------------------------+\n|  BlockchainConnector   |                     |  BlockchainConnector   |\n|  (Source Chain)        |                     |  (Destination Chain)   |\n+------------------------+                     +------------------------+\n| - Manages Web3 conn.   |                     | - Manages Web3 conn.   |\n| - Provides contract obj|                     | - Provides contract obj|\n+------------------------+                     +------------------------+\n\n```\n\n*   **`ConfigLoader`**: Safely loads and validates required configuration (RPC URLs, private keys, etc.) from a `.env` file. This prevents hardcoding sensitive information.\n*   **`BlockchainConnector`**: A reusable class that manages the `web3.py` connection to a specific blockchain node. It handles the initial connection and provides a simple interface for interacting with smart contracts.\n*   **`EventScanner`**: The core component for the source chain. It periodically scans block ranges for a specific event. To ensure robustness, it persists its state (the last block it scanned) to a local JSON file (`scanner_state.json`), allowing it to resume where it left off after a restart. It also uses a confirmation block delay to mitigate the risk of processing events from blockchain re-organizations (re-orgs).\n*   **`TransactionRelayer`**: The core component for the destination chain. It takes processed event data, constructs a corresponding transaction (e.g., `claimWithdrawal`), signs it with the relayer's private key, and logs the result. In this simulation, it does not broadcast the transaction, simplifying the logic and avoiding real gas costs.\n*   **`BridgeListener`**: The main orchestrator. It initializes all other components, contains the main application loop, and coordinates the flow of data from the `EventScanner` to the `TransactionRelayer`.\n\n## How It Works\n\nThe listener operates in a continuous loop with the following steps:\n\n1.  **Initialization**: On startup, the `ConfigLoader` reads the `.env` file. The `BridgeListener` then creates `BlockchainConnector` instances for both the source and destination chains.\n2.  **State Loading**: The `EventScanner` loads its last processed block number from `scanner_state.json`. If the file doesn't exist, it defaults to the current block number of the source chain.\n3.  **Scanning**: In each loop iteration, the `EventScanner` determines the block range to scan. It queries the source chain's RPC for `DepositInitiated` events between `last_scanned_block + 1` and `current_block - confirmation_blocks`.\n4.  **Event Processing**: If any events are found, the `BridgeListener` iterates through them.\n5.  **Data Extraction**: For each event, it extracts the relevant data (e.g., the user's address, the deposit amount, and the source transaction hash).\n6.  **Transaction Simulation**: The extracted data is passed to the `TransactionRelayer`. The relayer builds a `claimWithdrawal` transaction, sets the nonce and gas parameters, and signs it using the relayer's private key.\n7.  **Logging**: The signed raw transaction and its simulated hash are logged to the console. **No transaction is actually sent.**\n8.  **State Update**: Finally, the `EventScanner` updates `last_scanned_block` to the last block number it successfully scanned and persists this state to the local file.\n9.  **Wait**: The application pauses for a configurable interval (`BLOCK_PROCESSING_INTERVAL_SECONDS`) before starting the next scanning cycle.\n\n## Usage\n\n### 1. Set Up Environment\n\nFirst, clone the repository:\n```bash\ngit clone https://github.com/your-username/ftt_mix.git\ncd ftt_mix\n```\n\nCreate a Python virtual environment and install the required dependencies:\n```bash\npython -m venv venv\nsource venv/bin/activate  # On Windows, use `venv\\Scripts\\activate`\npip install -r requirements.txt\n```\n\n### 2. Create a Configuration File\n\nCreate a file named `.env` in the root of the project directory. This file will hold your configuration and secrets. Populate it with the following content, replacing the placeholder values.\n\n*For a practical test, you can use a public Ethereum RPC and the Wrapped Ether (WETH) contract, as its `Deposit` event has a structure compatible with our simulated `DepositInitiated` event.*\n\n```dotenv\n# --- Source Chain (e.g., Ethereum Mainnet) ---\n# Get a free RPC URL from a provider like Infura or Alchemy\nSOURCE_CHAIN_RPC_URL=\"https://mainnet.infura.io/v3/YOUR_INFURA_PROJECT_ID\"\n# WETH contract address on Ethereum, which has a `Deposit` event\n# We will pretend its `Deposit(address indexed dst, uint wad)` event is our `DepositInitiated`\nSOURCE_BRIDGE_CONTRACT_ADDRESS=\"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\"\n\n# --- Destination Chain (e.g., Polygon) ---\nDESTINATION_CHAIN_RPC_URL=\"https://polygon-rpc.com/\"\n# A placeholder address for the destination contract\nDESTINATION_BRIDGE_CONTRACT_ADDRESS=\"0x1234567890123456789012345678901234567890\"\n\n# --- Relayer Configuration ---\n# IMPORTANT: Use a burner private key with NO real funds for this simulation.\nRELAYER_PRIVATE_KEY=\"0xYOUR_BURNER_PRIVATE_KEY_WITHOUT_FUNDS\"\n\n# --- Listener Configuration ---\n# How often the script should scan for new blocks (in seconds)\nBLOCK_PROCESSING_INTERVAL_SECONDS=30\n# Number of blocks to wait before processing an event to avoid re-orgs\nCONFIRMATION_BLOCKS=12\n```\n\n**Note**: The ABIs included in the script are minimal, containing only the necessary event and function signatures for this simulation. For example, the source ABI for `DepositInitiated(address, uint256)` is intentionally compatible with the WETH contract's `Deposit(address, uint256)` event signature, which allows for easy live testing.\n\n### 3. Run the Script\n\nExecute the main script from your terminal:\n```bash\npython script.py\n```\n\n### 4. Expected Output\n\nThe script will start logging its activities to the console. When it finds a new event on the source contract, you will see output similar to this:\n\n```\n2023-10-27 15:30:00,123 - INFO - [BridgeListener] - Bridge Listener starting up...\n2023-10-27 15:30:05,456 - INFO - [EventScanner] - Scanning for 'DepositInitiated' events from block 18450001 to 18450050.\n2023-10-27 15:30:08,789 - INFO - [EventScanner] - Found 1 new 'DepositInitiated' event(s).\n2023-10-27 15:30:08,790 - INFO - [BridgeListener] - Processing event from tx 0x...: User 0x... deposited 0.5 tokens.\n2023-10-27 15:30:08,791 - INFO - [TransactionRelayer] - Preparing to relay claim for user 0x... for amount 500000000000000000.\n2023-10-27 15:30:09,999 - INFO - [TransactionRelayer] - Successfully signed transaction to claim withdrawal.\n2023-10-27 15:30:10,000 - INFO - [TransactionRelayer] -   - TX Hash (simulated): 0x...\n2023-10-27 15:30:10,001 - INFO - [TransactionRelayer] -   - Raw TX (simulated): 0x...\n2023-10-27 15:30:35,000 - INFO - [BridgeListener] - Sleeping for 30 seconds...\n```"
}